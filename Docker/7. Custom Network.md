Key Concepts
- Top-level networks key: You define your custom networks at the root of the docker-compose.yml file.
- Service-level networks key: Within each service definition, you specify which of the custom networks that service should connect to.
- Network Isolation: Services can only communicate with other services that are on the same custom network. A service on a frontend-net cannot talk to a service that is only on a backend-net unless it is connected to both.
- Network Alias: You can assign network-specific aliases to a service, allowing it to be addressed by different names on different networks.



1. First, create a project directory named `network-app` and navigate into it.
```
mkdir network-app && cd network-app
```


2. Create a `docker-compose.yml` file that defines two custom networks (`frontend` and `backend`) and three services. The `proxy` service will connect to both networks, `webapp` will only connect to `frontend`, and `api` will only connect to `backend`.
```
cat <<EOF > docker-compose.yml
services:
  proxy:
    image: nginx:alpine
    networks:
      - frontend
      - backend
  webapp:
    image: nginxdemos/hello
    networks:
      - frontend
  api:
    image: busybox
    command: "sleep 3600"
    networks:
      - backend

networks:
  frontend:
  backend:
EOF
````


3. Start the application in detached mode.
```
sudo docker compose up -d
```


4. From the `proxy` container, ping the `webapp` service to confirm connectivity on the `frontend` network.
```
sudo docker compose exec proxy ping -c 2 webapp
```

5. From the `proxy` container, ping the `api` service to confirm connectivity on the `backend` network.
```
sudo docker compose exec proxy ping -c 2 api
```


6. Now, attempt to ping the `api` service from the `webapp` container. This should fail, demonstrating network isolation.
```
sudo docker compose exec webapp ping -c 2 api
```
