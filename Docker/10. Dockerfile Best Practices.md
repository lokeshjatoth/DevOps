Key Best Practices
- Use a .dockerignore file: Just like .gitignore, this file tells Docker to exclude certain files and directories (like .git, logs, or local development files) from the build context. This prevents them from being sent to the Docker daemon, speeding up builds and reducing image size.

- Leverage Build Cache: Order your Dockerfile instructions from least frequently changing to most frequently changing. For example, copy your package manifest file and install dependencies *before* copying your application source code. This way, Docker can reuse the cached layer for dependencies if your source code changes but your dependencies do not.

- Use Multi-Stage Builds: This is a powerful technique for creating small, production-ready images. You use one stage (e.g., with a full SDK) to build or compile your application, and a second, much smaller stage (e.g., a minimal runtime image) to copy *only* the compiled artifacts into. This eliminates build tools and intermediate files from the final image.

- Choose Minimal Base Images: Start with a small, secure base image like alpine, slim, or a distroless image instead of a full OS image like ubuntu.

- Avoid Root User: Always add a non-root user inside your Dockerfile for improved container security. Root inside containers = root on host (in some misconfigured cases).



1. Create a project directory named `optimized-app` and navigate into it.
```
mkdir optimized-app && cd optimized-app
```


2. Create a simple Node.js application file named `server.js`.
```
cat <<EOF > server.js
const http = require("http");
const server = http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("Hello from Optimized App!\n");
});
server.listen(3000, "0.0.0.0", () => {
  console.log("Server running on port 3000");
});
EOF
```

3. Create a `package.json` file. This is analogous to a `requirements.txt` in Python.
```
cat <<EOF > package.json
{
  "name": "optimized-app",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  }
}
EOF
```

4. Create a `.dockerignore` file to exclude the `node_modules` directory and `.log` files from the build context.
```
cat <<EOF > .dockerignore
node_modules
*.log
EOF
```


5. Create a single-stage `Dockerfile.single` that does not use multi-stage build. This will simulate an unoptimized image.
```
cat <<EOF > Dockerfile.single
FROM node:18
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 3000
CMD ["npm", "start"]
EOF
```


6. Build the unoptimized image using the `Dockerfile.single`. Tag it as `unoptimized-webapp`.
```
sudo docker build -f Dockerfile.single -t unoptimized-webapp .
```

7. List the image size of `unoptimized-webapp`. We will compare this to the optimized one later.
```
sudo docker images unoptimized-webapp
```

8. Create a multi-stage `Dockerfile`. The first stage will be a "builder" to install dependencies, and the final stage will be a minimal runtime.
```
cat <<EOF > Dockerfile
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .

# Production stage
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app .
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser
EXPOSE 3000
CMD ["npm", "start"]
EOF
```


9. Build the optimized Docker image. Tag it `optimized-webapp`.
```
sudo docker build -t optimized-webapp .
```

10. List your local images and compare the sizes of `optimized-webapp` and `unoptimized-webapp`.
```
sudo docker images | grep webapp
```


11. Run the optimized container and test the output using curl.
```
sudo docker run -d --name optimized-app-container -p 3000:3000 optimized-webapp && sleep 2 && curl http://localhost:3000
```
