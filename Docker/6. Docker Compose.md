Install Docker 
```
sudo apt-get update && sudo apt-get install -y docker.io && sudo systemctl start docker &&  
sudo systemctl enable docker && sudo docker --version
```

Docker compose setup 
```
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
```

```
sudo apt install docker-compose-plugin
```

```
docker compose version
```

What is Docker Compose?
Docker Compose is a powerful orchestration tool that allows you to define and manage multi-container applications using a simple YAML configuration file. Instead of running multiple docker run commands with complex arguments, Compose lets you describe your entire application stack in a single file and manage it with simple commands.

Why Use Docker Compose?
- Real applications need multiple containers: web server, API, database, cache

- Eliminates manual docker run commands with complex arguments

- Manages inter-service communication and dependencies

- Provides reproducible environments across development, testing, and staging

- Enables automatic service discovery and isolated networking

- Simplifies scaling and deployment coordination

Core Docker Compose Concepts
- Services: Containerized components with pre-built/custom images and environment configuration

- Networks: Isolated networks where services communicate using service names as hostnames

- Volumes: Data persistence through named volumes, bind mounts, and anonymous volumes

Service Communication and Discovery
- Services communicate using service names as hostnames

- Each Compose application gets its own isolated network

- External access requires explicit port mapping

- Services from different applications remain isolated

Common Docker Compose Commands
- docker compose up: Start all services defined in compose file

- docker compose down: Stop and remove containers, networks

- docker compose ps: List running containers managed by Compose

- docker compose logs: View logs from services

- docker compose build: Build or rebuild services

Troubleshooting Common Issues
- Services can't communicate: Ensure same network, use service names as hostnames

- Port conflicts: Check if ports in use, modify host port mapping

- Volume data not persisting: Use named volumes instead of anonymous volumes

- Environment variables not working: Check .env file location and variable syntax

- Service startup order issues: Use depends_on and health checks for orchestration



First, create a project directory named compose-app and navigate into it.
```
mkdir compose-app && cd compose-app
```

Create a docker-compose.yml file that defines a simple web service using the nginxdemos/hello image.
```
cat <<EOF > docker-compose.yml
services:
  web:
    image: nginxdemos/hello
    ports:
      - "8080:80"
EOF
```

Start the application in detached mode using Docker Compose.
```
sudo docker compose up -d
```

List the running containers managed by Docker Compose.
```
sudo docker compose ps
```

Check the logs for the `web` service.
```
sudo docker compose logs web
```

Use `curl` to verify that the web server is running and accessible on port 8080.
```
curl http://localhost:8080
```
