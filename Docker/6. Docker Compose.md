Install Docker 
```
sudo apt-get update && sudo apt-get install -y docker.io && sudo systemctl start docker &&  
sudo systemctl enable docker && sudo docker --version
```

Docker compose setup 
```
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
```

```
sudo apt install docker-compose-plugin
```

```
docker compose version
```

What is Docker Compose?
Docker Compose is a powerful orchestration tool that allows you to define and manage multi-container applications using a simple YAML configuration file. Instead of running multiple docker run commands with complex arguments, Compose lets you describe your entire application stack in a single file and manage it with simple commands.

Why Use Docker Compose?
- Real applications need multiple containers: web server, API, database, cache

- Eliminates manual docker run commands with complex arguments

- Manages inter-service communication and dependencies

- Provides reproducible environments across development, testing, and staging

- Enables automatic service discovery and isolated networking

- Simplifies scaling and deployment coordination

Core Docker Compose Concepts
- Services: Containerized components with pre-built/custom images and environment configuration

- Networks: Isolated networks where services communicate using service names as hostnames

- Volumes: Data persistence through named volumes, bind mounts, and anonymous volumes

Service Communication and Discovery
- Services communicate using service names as hostnames

- Each Compose application gets its own isolated network

- External access requires explicit port mapping

- Services from different applications remain isolated

Common Docker Compose Commands
- docker compose up: Start all services defined in compose file

- docker compose down: Stop and remove containers, networks

- docker compose ps: List running containers managed by Compose

- docker compose logs: View logs from services

- docker compose build: Build or rebuild services

Troubleshooting Common Issues
- Services can't communicate: Ensure same network, use service names as hostnames

- Port conflicts: Check if ports in use, modify host port mapping

- Volume data not persisting: Use named volumes instead of anonymous volumes

- Environment variables not working: Check .env file location and variable syntax

- Service startup order issues: Use depends_on and health checks for orchestration



1. First, create a project directory named compose-app and navigate into it.
```
mkdir compose-app && cd compose-app
```

2. Create a docker-compose.yml file that defines a simple web service using the nginxdemos/hello image.
```
cat <<EOF > docker-compose.yml
services:
  web:
    image: nginxdemos/hello
    ports:
      - "8080:80"
EOF
```

3. Start the application in detached mode using Docker Compose.
```
sudo docker compose up -d
```

4. List the running containers managed by Docker Compose.
```
sudo docker compose ps
```

5. Check the logs for the `web` service.
```
sudo docker compose logs web
```

6. Use `curl` to verify that the web server is running and accessible on port 8080.
```
curl http://localhost:8080
```

Key Concepts
- Service Inter-dependencies: Applications are often composed of multiple services (e.g., web server, database, caching layer). Docker Compose allows you to define each of these in one file.
- Service Discovery: By default, Docker Compose puts all services into a single network. This allows containers to find and communicate with each other using their service names. For example, your 'web' service can connect to your 'redis' service using the hostname redis.
- depends_on: Controls startup order. Modern Docker Compose (v2+) uses simple list format: depends_on: - redis
- Healthchecks: You can add healthcheck to services so Compose can monitor service health. Note: condition-based depends_on is deprecated in v2.
- Persistence: Named volumes let data (like Redis keys) survive container restarts.
- Scaling: docker compose up --scale web=3 runs multiple containers for a service (great for stateless web tiers).
- Profiles (advanced): Use profiles to add optional services (e.g., a reverse proxy) without changing the base stack.


1. Create a project directory named `multi-container-app` and navigate into it.
```
mkdir multi-container-app && cd multi-container-app
```


2. Create a minimal `docker-compose.yml` defining two services: `web` (using `nginx:latest`) and `redis` (using `redis:alpine`). Expose the web app on host port 5001.
```
cat <<EOF > docker-compose.yml
services:
  redis:
    image: redis:alpine
  web:
    image: nginx:latest
    ports:
      - "5001:80"
    depends_on:
      - redis
EOF
```

3. Start the application in detached mode.
```
sudo docker compose up -d
```

4. List running containers and confirm both services are up.
```
sudo docker compose ps
```


5. Test the web app via `curl` to ensure it is running.
```
curl http://localhost:5001
```

6. Add a healthcheck to Redis and make `web` depend on Redis startup. Also add a volume for Redis data persistence. Update `docker-compose.yml` accordingly.
```
cat <<'EOF' > docker-compose.yml
services:
  redis:
    image: redis:alpine
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
    volumes:
      - redis-data:/data

  web:
    image: nginx:latest
    ports:
      - "5001:80"
    depends_on:
      - redis

volumes:
  redis-data:
EOF
```


7. Restart the stack to apply healthcheck and volume changes.
```
sudo docker compose up -d --force-recreate
```


8. Exec into Redis and inspect keys to see what data is stored.
```
sudo docker compose exec redis redis-cli keys "*"
```
