Why Docker Networking Matters
- Web Frontend, API Backend, Databases, Caching, Message Queues need to communicate

- Hardcoded IP addresses change when containers restart causing connectivity issues

- No service discovery mechanism between containers creates management complexity

- Security vulnerabilities from exposed internal services

- Complex port management across different environments

- Service Discovery: Containers can find each other by name

- Network Isolation: Logical separation of different application tiers

- Dynamic IP Management: Automatic IP allocation and DNS resolution

- Security Boundaries: Network-level access control

Docker Network Architecture Overview
- Docker Daemon manages all networking components and interfaces

- Bridge Network (docker0): Default container networking

- Custom Networks: User-defined isolated networks with DNS resolution

- Host Network: Direct host network access for performance-critical applications

- None Network: Completely isolated containers with no network access

- Port mapping enables external connectivity through host interfaces

- Network interfaces include eth0 (external), lo (loopback), docker0 (bridge)

Docker Network Drivers
- Bridge Network: Default driver for single-host communication

- Custom Bridge Networks: Recommended for production with built-in DNS resolution

- Host Network: Performance-critical applications sharing host network stack

- None Network: Complete isolation for security-sensitive containers

- Overlay Networks: Multi-host networking for distributed applications

Service Discovery and DNS
- Container Name Resolution: Containers can communicate using container names

- Network Aliases: Flexible naming for services within custom networks

- Cross-Network Communication: Containers on different networks require explicit connection

Port Publishing and Access
- Port Publishing: Maps container ports to host ports for external access

- Container-to-Container Communication: Direct communication without port publishing on same network

- Internal Services: Keep databases and internal APIs on private networks



List the existing Docker networks on your system to see the defaults.
```
sudo docker network ls
```


Create a new custom bridge network named `app-network`.
```
sudo docker network create app-network
```


Run a detached Nginx container named `web-server` and attach it to your new `app-network`.
```
sudo docker run -d --name web-server --network app-network nginx
```

Run a second container using `busybox`, named `client-box`, on the same network to test connectivity. This container will be used to ping the web server.
```
sudo docker run -d --name client-box --network app-network busybox sleep 3600
```

From `client-box`, ping the `web-server` by its container name to test Dockerâ€™s internal DNS.
```
sudo docker exec client-box ping -c 2 web-server
```

Clean up the test containers now that DNS is verified.
```
sudo docker rm -f web-server client-box
```


Expose a new Nginx container named `web-server-exposed` to the host on port 8080.
```
sudo docker run -d --name web-server-exposed -p 8080:80 nginx
```


From your host, use `curl` to confirm that Nginx is accessible at `http://localhost:8080`.
```
curl http://localhost:8080
```

Run a container with no network access.
```
sudo docker run -dit --name no-net-container --network none busybox sh
```

Attempt to ping an external address from the `no-net-container`. This will fail, proving it has no network connectivity.
```
sudo docker exec no-net-container ping -c 1 1.1.1.1
```
