Why Do We Need Data Persistence?
- Databases: PostgreSQL, MySQL, MongoDB need to persist data between restarts

- User Uploads: Web applications storing user files, images, documents

- Configuration: Application settings and customizations

- Logs: Important application logs for debugging and monitoring

- Development: Code changes during development need to persist

- Database records vanish during deployments without persistence

- User-generated content is lost when containers are recreated

- Application configurations reset to defaults

- Development work is lost between sessions

Docker Volume Architecture
- Containers can mount volumes at different paths and share persistent storage

- Volume persists independently of container lifecycle

- Docker manages volumes in /var/lib/docker/volumes/ directory

- Volume data survives container restarts and removal

- Multiple containers can mount the same volume simultaneously

Types of Docker Storage Mounts
- Named Volumes: Managed by Docker, portable, shareable, recommended for production

- Anonymous Volumes: Auto-created with random names, harder to manage and reuse

- Bind Mounts: Mount host directories, perfect for development with live reloading

- tmpfs Mounts: Memory storage for temporary data, very fast but ephemeral

Volume Lifecycle and Management
- Volumes are created when first referenced or pre-created with docker volume create

- Volumes persist independently of containers

- Multiple containers can mount the same volume for data sharing

- Common pattern: app container + backup container sharing volumes

- Volumes don't auto-delete when containers are removed

- Manual cleanup required with docker volume prune to prevent data loss

Production Best Practices
- Use specific volume drivers for encryption and proper access controls

- Implement regular backup strategies and monitor volume usage

- Choose appropriate volume drivers based on I/O patterns

- Use tmpfs for high-speed temporary data

- Monitor disk space and IOPS performance

- Prefer named volumes over bind mounts in production

- Document volume requirements in docker-compose files

- Use volume drivers compatible with deployment platform

1. Create a Docker volume named "app-data".
```
sudo docker volume create app-data
```


2. List and inspect the "app-data" volume to see its host path.
```
sudo docker volume ls && sudo docker volume inspect app-data
```

3. Create a container named "writer-1" and mount "app-data" to `/data`. Keep it running.
```
sudo docker run -dit --name writer-1 -v app-data:/data busybox sh
```

4. From inside "writer-1", create a file with some data on the volume.
```
sudo docker exec writer-1 sh -c "echo one_from_writer1 > /data/file.txt"
```

5. Start a second container named "writer-2" and mount the same volume to `/mnt`. Keep it running.
```
sudo docker run -dit --name writer-2 -v app-data:/mnt busybox sh
```


6. From inside "writer-2", read the file created by "writer-1".
```
sudo docker exec writer-2 cat /mnt/file.txt
```


7. Append a line to the same file from inside "writer-2".
```
sudo docker exec writer-2 sh -c "echo two_from_writer2 >> /mnt/file.txt"
```

8. Validate the content from inside "writer-1" to confirm changes from both containers are visible.
```
sudo docker exec writer-1 cat /data/file.txt
```

9. Now delete both containers (but do not delete the volume).
```
sudo docker rm -f writer-1 writer-2
```


10. Run a temporary container and mount "app-data" to validate the file contents.
```
sudo docker run --rm -v app-data:/check busybox cat /check/file.txt
```

11. Practice with a bind mount: create a host directory and use it in a new container.
```
mkdir -p /tmp/dind && sudo docker run -dit --name bind-test -v /tmp/dind:/dind busybox sh
```


12. Write a file into the bind mount from inside the container.
```
sudo docker exec bind-test sh -c "echo bind_test_data > /dind/test.txt"
```

13. Verify the file appears on the host system.
```
cat /tmp/dind/test.txt
```


14. Clean up the bind mount container.
```
sudo docker rm -f bind-test
```