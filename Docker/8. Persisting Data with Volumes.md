Key Concepts
- Top-level volumes key: Similar to networks, you declare named volumes at the root of your docker-compose.yml file. This tells Compose to manage the volume's lifecycle.

- Service-level volumes key: Inside a service definition, you use this key to mount the named volume into a specific path inside the container. The syntax is <volume_name>:<container_path>.

- Data Persistence: When you run docker compose down, by default it does not remove named volumes. This is a safety feature to prevent accidental data loss. To remove volumes, you must explicitly use the -v flag: docker compose down -v.

- Healthchecks: Add a healthcheck so other services wait until the DB is ready. This makes multi-service stacks more reliable.

- One-off tasks: Use docker compose exec/run to run ad-hoc commands (like psql) against a running service without baking tools into the image.

- Backups & Restores: You can archive a named volume’s contents to the host (tar), and later restore into a fresh volume—no DB-specific tooling required.

- Read-only mounts: Use :ro for things like init scripts to avoid accidental changes from inside the container.


1. First, create a project directory named `volume-app` and navigate into it.
```
mkdir volume-app && cd volume-app
```

2. Create a `docker-compose.yml` file that defines a PostgreSQL database service. It should use a named volume called `db-data` to persist its data.
```
cat <<EOF > docker-compose.yml
services:
  db:
    image: postgres:13-alpine
    environment:
      - POSTGRES_PASSWORD=mysecretpassword
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:
EOF
```

3. Start the database service in detached mode.
```
sudo docker compose up -d
```


4. Wait a few seconds for the database to initialize, then stop and remove the container. We will *not* remove the volume yet.
```
sleep 10 && sudo docker compose down
```

5. List the Docker volumes on your system. You should see that the `volume-app_db-data` volume still exists.
```
sudo docker volume ls
```

6. Start the application again. Because the volume persists, PostgreSQL will detect the existing data and use it instead of re-initializing.
```
sudo docker compose up -d
```


7. Check the logs of the `db` service. You should see messages indicating the database system was not re-initialized and is ready.
```
sudo docker compose logs db
```

8. Upgrade your compose file to add a healthcheck and useful env vars. Recreate `docker-compose.yml` with a `healthcheck` and `POSTGRES_USER`/`POSTGRES_DB`.
```
cat <<'EOF' > docker-compose.yml
services:
  db:
    image: postgres:13-alpine
    environment:
      - POSTGRES_USER=appuser
      - POSTGRES_PASSWORD=mysecretpassword
      - POSTGRES_DB=appdb
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U appuser -d appdb || exit 1"]
      interval: 5s
      timeout: 3s
      retries: 10
    volumes:
      - db-data:/var/lib/postgresql/data
      - ./init:/docker-entrypoint-initdb.d:ro

volumes:
  db-data:
    labels:
      owner: "labs"
      purpose: "postgres-data"
EOF
```


9. Create an `init` directory with a seed SQL file that will run only on the first initialization (and be ignored on subsequent starts due to persisted data).
```
mkdir -p init && cat <<'SQL' > init/001_seed.sql
CREATE TABLE IF NOT EXISTS notes(id SERIAL PRIMARY KEY, body TEXT NOT NULL);
INSERT INTO notes(body) VALUES ('hello-from-seed');
SQL
```


10. Recreate the stack and wait for it to be healthy. Then connect and query data using a one-off `psql` command.
```
sudo docker compose up -d --wait && \
sudo docker compose exec -T db psql -U appuser -d appdb -c "SELECT * FROM notes;"
```



11. Insert a new row to prove writes land on the volume. Then bring the stack down and back up; verify the new row persists.
```
sudo docker compose exec -T db psql -U appuser -d appdb -c "INSERT INTO notes(body) VALUES ('persist-me');" && \
sudo docker compose down && \
sudo docker compose up -d --wait && \
sudo docker compose exec -T db psql -U appuser -d appdb -c "SELECT * FROM notes WHERE body='persist-me';"
```


12. Inspect the named volume to discover its host mountpoint.
```
sudo docker volume inspect volume-app_db-data
```

13. Create a tarball backup of the named volume contents on the host. This is a generic (engine-agnostic) backup approach.
```
sudo docker run --rm \
  -v volume-app_db-data:/data:ro \
  -v "$PWD":/backup \
  busybox sh -c "tar czf /backup/db-data.tgz -C /data ." && \
ls -lh db-data.tgz
```

14. Simulate data loss by removing the stack and volume. Then restore from the tarball into a fresh volume and verify data.
```
sudo docker compose down -v && \
sudo docker volume rm volume-app_db-data || true && \
sudo docker volume create volume-app_db-data && \
sudo docker run --rm \
  -v volume-app_db-data:/data \
  -v "$PWD":/backup \
  busybox sh -c "mkdir -p /data && tar xzf /backup/db-data.tgz -C /data" && \
sudo docker compose up -d --wait && \
sudo docker compose exec -T db psql -U appuser -d appdb -c "SELECT count(id) FROM notes;"
```


15. Make the init mount read-only (already `:ro`) and confirm you cannot write to it from inside the container.
```
sudo docker compose exec -T db sh -lc "echo test > /docker-entrypoint-initdb.d/cant-write || echo RO-OK"
```