Dockerfile Build Process Architecture
- Build Context: Contains Dockerfile, source code, and configuration files

- Docker Build Process: Creates layers for each instruction in sequential order

- Layer Structure: FROM creates base layer, RUN/COPY add content, CMD defines runtime

- Final Image: All layers are read-only, cacheable, and stack from base to application

- Image Size: Total size depends on base image and added content, compressed for distribution



Dockerfile Instruction Reference and Best Practices
- FROM: Always use specific tags, avoid generic tags like latest, choose appropriate base images

- WORKDIR: Set consistent working directory, avoid /root or /, create directory structure as needed

- COPY vs ADD: Use COPY for simple operations, ADD for URLs and auto-extraction, use .dockerignore for optimization

- RUN: Combine related commands to reduce layers, order matters for caching, clean up package caches

- ENV and ARG: Set environment variables for runtime, use ARG for build-time variables

- EXPOSE: Documents ports but doesn't publish them

- CMD vs ENTRYPOINT: CMD can be overridden, ENTRYPOINT is fixed, combine for flexibility



1. Create a project directory called webapp.
```
mkdir webapp
```

2. Navigate into the webapp directory.
```
cd webapp
```

3. Create a simple Python file named app.py that runs a Flask app.
```
cat <<EOF > app.py
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello, Docker!"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
EOF
```

4. Create a requirements.txt file specifying Flask and Werkzeug versions.
```
cat <<EOF > requirements.txt
Flask==2.2.2
Werkzeug==2.2.3
EOF
```


5. Create a Dockerfile with CMD and ENTRYPOINT.
```
cat <<EOF > Dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY app.py .
RUN adduser --disabled-password --gecos "" appuser && chown -R appuser /app
USER appuser
EXPOSE 5000
ENTRYPOINT ["python"]
CMD ["app.py"]
EOF
```

6. Create a .dockerignore file to exclude unnecessary files from the build.
```
cat <<EOF > .dockerignore
__pycache__
*.pyc
*.log
.env
EOF
```


7. Build the Docker image and tag it as my-first-webapp.
```
sudo docker build -t my-first-webapp .
```



8. Run the image in a container named flask-app on port 5000.
```
sudo docker run -d --name flask-app -p 5000:5000 my-first-webapp
```



9. Inspect the container to verify which user it runs as.
```
docker exec flask-app whoami
```



10. Check what command is configured in the image.
```
docker inspect my-first-webapp | grep -A 1 Entrypoint
```



11. Curl to localhost and access the application.
```
curl localhost:5000
```
